# class 4/2024.3.19
## chapter 4: leftist heaps and skew heaps
### leftist heaps
#### 与正常堆对比：
将两个堆合并成一个堆的速度：

正常，对于数组操作而言，必须要拷贝一个堆到另一个堆上，这就是O(N);

对于指针操作而言，其他操作的速度就会变慢。

leftist heap的目的，加快合并/插入的速度，提升至O(logn)

#### 特征：
- 堆的数据大小结构不变
- 堆越不平衡越好

定义null path length(Npl(X))为从X到某叶子节点的最短路径

(默认Npl(NULL) = -1 换言之，所有叶子节点，以及只有一个孩子的节点，其Npl均为0)

迭代式：$Npl(X) = min\{Npl(C) + 1, C~is~the~children~of~X\}$

对于leftist heap有如下定义：

对于堆中的任意节点X，有：

$Npl(X->left) \geq Npl(X->right)$

**注：这并不意味着左子树的节点个数一定比右子树的节点个数多。**

*因为有一个孩子的节点，其Npl也为0*

- 有如下定理：
对一个leftist heap, 若右侧路径长度为r，总共节点至少有$2^r - 1$

反过来，对于一个具备N个节点的leftist heap, 右路径最长为$log_n(N + 1)$

#### 操作：
建立结构为
```c
struct heap{
    int data;
    int* left;
    int* right;
    int Npl;
};
```

方式如下（假设为小根堆）：
- 比较H1，H2的根节点大小，把大者（设为H2）与小者（设为H1）的右子树交换
- 令H1的右节点为新的H1，再做第一步，直至完全合并
- 从插入点开始回溯，逐个调整左右节点，令堆变为leftist heap

*注：在第一步中，如果左子树为空，直接把树接到左子树就结束了，避免处理时需要再换一次*

*理论上不换也行（因为最后都要调整），但是在比较Npl时，NULL的特殊情况要单列出来*

而在正常的操作中，H1,H2在结尾讨论时永远不可能两个都为空，因此目标节点及其所有根节点左右子树都存在

故而不需要特判NULL

而对于Delete，同理，只需要消掉根节点，两个子树合并即可。

#### 分析：
此时插入/合并/删除的复杂度均为O(logN).

### skew heap
与AVL和splay的关系一样，考虑放松条件：

连续M个操作，使用O(MlogN)的时间复杂度。

#### 操作方法：
不再记录Npl，每次都换左右子树

例如两个堆，根节点分别为3，6

那么将3的左右节点互换，将6这个堆与现在的3的左节点互换，以此类推

- 优点是不再需要记录、计算及比较Npl
