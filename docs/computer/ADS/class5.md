# class 5/2024.3.26
## binomial queue
### 解决问题：
继承上一节课的左高堆，它对于插入操作：

具备O(logN)的时间复杂度。、

我们希望能够令它变得更快。

### 结构：
binomial queue（二项队列）是多个堆的集合。

每个堆被称作binomial tree（二项树）。

对于每个树（设为$B_k$），它由两个$B_{k-1}$构成，其中一个树的根作为另一个树的根的子节点。

换言之，对于$B_k$，它不再是二叉树。

根据定义，于是有如下性质：
- $B_k$拥有k个孩子
- 每个孩子是$B_0,B_1,...,B_{k-1}$
- $B_k$有$2^k$个节点
- 对于深度为d的节点个数，其分布满足二项分布

### 使用方式及操作：
举例：用binomial queue表示节点个数为13的堆：

13 = $1101_2$

因此，binomial queue中有$B_0, B_2, B_3$

#### 寻找最小值：
对于小根堆，最小值在几个堆中的某个根节点，因此复杂度为$O(log_2N)$

#### 合并：
合并操作跟二进制加法很相似，结合的方式就是之前定义的树的结构

即对于相同位的B(可以设为$B1_x, B2_x$)，将一个树的根节点作为另一个树根节点的子节点（要满足堆的性质），然后进位

如果出现1+1+1的情况，可任选两个作为进位的树，剩下的仍作为这个位的树

那么对于一次合并，所需的操作数就是逐位相加的次数，因此复杂度为O(logN).

#### 插入：
插入是一种特殊的合并操作。

那么就是从最低位开始逐位进位，直至到某个为空的位就停止。

即插入一次所需时间为 $T=const\times (i + 1)$，i为为空的树的位数

因此，对于插入N个节点，它的时间复杂度应为O(N)，因为平均时间是一个常数。

#### 删除（deletemin）：
删除分为以下几步：
- 找到最小的值
- 拿掉它（它一定是根节点）
- 将它的子节点们与原来的节点进行合并即可

综合的复杂度仍为O(logN).

#### 具体数据结构：
binomial queue用指针数组

binomial tree用左儿子右兄弟的方式以类二叉树表示

具体的函数实现中，PPT上给出了一个绝妙的方法，直接看PPT就行。